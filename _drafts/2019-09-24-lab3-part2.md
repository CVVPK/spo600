---
layout: post
title: lab3 part2
date: 2019-09-24
---

In this post we are going to learn how to write a loop in assembly. As we saw in [Part 1]() writing simple programs in assembly is a lot more complex than writing them in C. However, the resulting program is much smaller and faster to execute than compiled C.

This is Part 2 of a a 2 part series Intro to Assembly. It continues from what we worked on in [Lab 3](https://wiki.cdot.senecacollege.ca/wiki/SPO600_Assembler_Lab). 


<!-- more -->
## Initial Loop

First we are going to see what it takes to create a loop. From [Part 1]() we already know how to print a message to the screen. Now we would like to print a message multiple times. If you have written a for loop on almost any other program, you know we need a condition so that we know when to stop the loop.

We begin by defining two macros, `start` will serve as the initial value of the iterator and `max` will be the maximum number of times we want to loop:

```
start = 0
max = 10
```

We need a way to keep track of the iteration we are in, we are going to use `r15` to do so. So to initiate our iterator we move `start` to `r15`:

```
mov $start, %r15
```
We will have to then increment the value stored in `r15` after each loop, just before doing checking our condition. To increment the value in the register we simply write:

```
inc %r15
```


Now that we have an iterator that can increment on each loop, a macro that defines the maximum number of loops we want; all we're missing is a way to check that the iterator does not exceed the maximum value. So, to compare it we write:

```
cmp $max, %r15
```

This will set a flag in the processor status register depending on whether they are equal or not. We can then use this flag to jump to a label, in our case we want to jump back the start of the `loop` label if the condition is false, we can do this with the following line:

```
jne loop
```

All we're missing now is a message to print to the screen. We do the same thing we did in our Hello World! program to print something to the CL:

```
	mov	$len,%rdx
	mov	$msg,%rsi
	mov	$stdout,%rdi
```

Where `msg` and len are declared below:

```
.data
msg:	.ascii	"Loop\n"
.set	len , . - msg
```

The finished code should look something like this in x86_64: 

```
.text
.globl	_start

stdout = 1

start = 0
max = 10

_start:
	mov	$start,%r15

loop:
	mov	$len,%rdx
	mov	$msg,%rsi
	mov	$stdout,%rdi
	
	mov	$1,%rax
	syscall

	inc	%r15
	cmp	$max,%r15
	jne	loop

	mov	$0,%rdi
	mov	$60,%rax
	syscall

.data
msg:	.ascii	"Loop\n"
.set	len , . - msg

```

The code in AArch64 looks very similar, I'll go over the differences that stand out.

We will use the same macros as before to initialize our iterator and define the limit. Something to keep in mind when working with AArch64 is the order of the operations are different to x86_64 . The order in which we declare an operation in x86_64 goes: `instruction value,register` while on AArch it is `instruction register,value`. So say a move instruction in x86_64 looks something like this:

```
mov $1,%r15
```

In AArch64 it would be something like this:

```
mov w19,1
```

A few other things to note are the lack of `$` and `%`, and the `w` before the register number. In AArch64 apart from having more registers available to use than x86_64 we can also determine whether we wish to use a 32-bit register with `w` or a 64-bit register with `x`.

The logic of the program is the same as what we used for x86_64, we need an iterator to keep track of our loops, a condition and of course a message to print out.

This version of the program is pretty much the same, as you can see below:

```
.text
.globl	_start

stdout = 1

start = 0
max = 10

_start:
	mov	w19,start	/* Iterator */

loop:
	/* set up message */
	mov	x0, stdout
	adr	x1,msg
	mov	x2,len

	mov	x8,64		/* write message */
	svc	0
	
	add	w19,w19,1	/* Increment Iterator */
	cmp	w19,max		/* Check Iterator < max */
	b.ne	loop		/* Repeat if cmp ==false */

	mov	x0,0
	mov	x8,93
	svc	0

.data
msg:	.ascii	"Loop\n"
len = . - msg	
```

## Adding a loop number to the message

Now that we have got the basics of how to write a simple loop, we are going to make it a bit more fun. We will add the current iterator number to the message, so that it looks something like this `Loop: n` where 'n' is a different number on each line.

There are a few very important things to consider when we try to print something to the screen. First, we have to remember that 0 is not the same as "0". The first 0 represents a value, but "0" is a character. When trying to print a number to the CL we have to keep in mind the [ASCII]() codes for numbers begin at 48. So, 48="0", 49="1"...57="9". With this in mind, we now know that we are going to need to add 48 to whatever our iterator value is to get the correct ASCII value.

In this version of the program we are simply going to use a second register to keep track of the ASCII value of the iterator. However, this is only possible because the maximum value we want to display is "9". In a later version, when we display more than a single digit, we will see that this approach would not be very feasible.

The second thing to keep in mind is how we approach printing something to the screen. Keep in mind that `msg` occupies a fixed space in memory, and to print it out to the CL we simply reference its starting and ending points. 

Second Program, prints Loop: # where # is the iteration number.

```
.text
.globl	_start

stdout = 1

start = 0
max = 10

_start:
	mov	$start,%r15
	mov	$48, %r14

loop:
	mov	$len,%rdx
	mov	$msg,%rsi
	movb	%r14b,offset
	mov	$stdout,%rdi
	
	mov	$1,%rax
	syscall

	inc	%r15
	inc	%r14
	cmp	$max,%r15
	jne	loop

	mov	$0,%rdi
	mov	$60,%rax
	syscall

.data
msg:	.ascii	"Loop:  \n"
.set	len , . - msg
.set	offset, msg + 6
```

Third program, prints iterations with two digits, up to 29.

```
.text
.globl	_start

stdout = 1

start = 0
max = 30

_start:
	mov	$start,%r15	/* binary iterator start */
	mov	$10,%r12	/* divisor */
loop:
	mov	%r15, %rax
	mov	$0,%rdx
	div	%r12

	mov 	%rdx,%r14	/* second digit binary */
	mov	%rax,%r13	/* first digit binary */
	add	$48,%r13	/* convert 1st digit to ascii */
	add	$48,%r14	/* convert 2nd digit to ascii */
	
	mov	$len,%rdx
	mov	$msg,%rsi	/* message */
	movb	%r13b,offset1	/* first digit */
	movb	%r14b,offset2	/* second digit */
	mov	$stdout,%rdi
	
	mov	$1,%rax
	syscall

	inc	%r15		/* Increment Iterator */
	cmp	$max,%r15	/* Check Iterator < max */
	jne	loop			
	
	mov	$0,%rdi
	mov	$60,%rax
	syscall

.data
msg:	.ascii	"Loop:   \n"
.set	len , . - msg
.set	offset1, msg + 6
.set	offset2, msg + 7

```

Final program, it supress the leading 0.

```
.text
.globl	_start

stdout = 1

start = 0
max = 30

_start:
	mov	$start,%r15	/* binary iterator start */
	mov	$10,%r12	/* divisor */
loop:
	mov	%r15, %rax
	mov	$0,%rdx
	div	%r12

	mov 	%rdx,%r14	/* second digit binary */
	mov	%rax,%r13	/* first digit binary */
	add	$48,%r13	/* convert 1st digit to ascii */
	add	$48,%r14	/* convert 2nd digit to ascii */
	
	mov	$len,%rdx
	mov	$msg,%rsi	/* message */
	cmp	$48,%r13
	je	nozero
	movb	%r13b,offset1	/* first digit */
nozero:
	movb	%r14b,offset2	/* second digit */
	mov	$stdout,%rdi
	
	mov	$1,%rax
	syscall

	inc	%r15		/* Increment Iterator */
	cmp	$max,%r15	/* Check Iterator < max */
	jne	loop			
	
	mov	$0,%rdi
	mov	$60,%rax
	syscall	
.data
msg:	.ascii	"Loop:   \n"
.set	len , . - msg
.set	offset1, msg + 6
.set	offset2, msg + 7

```
### ARCH64

First:
```
.text
.globl	_start

stdout = 1

start = 0
max = 10

_start:
	mov	w19,start	/* Iterator */

loop:
	/* set up message */
	mov	x0, stdout
	adr	x1,msg
	mov	x2,len

	mov	x8,64		/* write message */
	svc	0
	
	add	w19,w19,1	/* Increment Iterator */
	cmp	w19,max		/* Check Iterator < max */
	b.ne	loop		/* Repeat if cmp ==false */

	mov	x0,0
	mov	x8,93
	svc	0

.data
msg:	.ascii	"Loop\n"
len = . - msg	
```

Second:

```
.text
.globl	_start

stdout = 1

start = 0
max = 10

_start:
	mov	w19,start	/* Iterator */
	mov	w20, 48
loop:

	/* set up message */
	mov	x0, 1
	adr	x1,msg
	mov	x2,len
	strb	w20,[x1,offset]

	mov	x8,64		/* write message */
	svc	0
	
	add	w19,w19,1	/* Increment Iterator */
	add	w20, w19,48
	cmp	w19,max		/* Check Iterator < max */
	b.ne	loop		/* Repeat if cmp ==false */

	mov	x0,0
	mov	x8,93
	svc	0

.data
msg:	.ascii	"Loop:  \n"
len = . - msg	
offset = msg + 6

```

Third:

```
.text
.globl	_start

stdout = 1

start = 0
max = 30

_start:
	mov	w19,start	/* Iterator */
	mov	w28,10

loop:
	udiv	w20, w19, w28	/* calculate first digit -0*/
	msub	w21,w20,w28,w19	/* calculate second digit 0- */

	add	w20,w20,48	/* convert first digit to ascii */
	add	w21,w21,48	/* convert second digit to ascii */

	/* set up message */
	mov	x0, 1
	adr	x1,msg
	mov	x2,len
	cmp	w20,48
	strb	w20,[x1,offset1]
	strb	w21,[x1,offset2]

	mov	x8,64		/* write message */
	svc	0
	
	add	w19,w19,1	/* Increment Iterator */
	cmp	w19,max		/* Check Iterator < max */
	b.ne	loop		/* Repeat if cmp ==false */

	mov	x0,0
	mov	x8,93
	svc	0

.data
msg:	.ascii	"Loop:   \n"
len = . - msg	
offset1 = msg + 6
offset2 = msg + 7

```

Last:

```
.text
.globl	_start

stdout = 1

start = 0
max = 30

_start:
	mov	w19,start	/* Iterator */
	mov	w28,10

loop:
	udiv	w20, w19, w28	/* calculate first digit -0*/
	msub	w21,w20,w28,w19	/* calculate second digit 0- */

	add	w20,w20,48	/* convert first digit to ascii */
	add	w21,w21,48	/* convert second digit to ascii */

	/* set up message */
	mov	x0, 1
	adr	x1,msg
	mov	x2,len
	cmp	w20,48
	b.eq	noleadzero
	strb	w20,[x1,offset1]

noleadzero:

	strb	w21,[x1,offset2]
	mov	x8,64		/* write message */
	svc	0
	
	add	w19,w19,1	/* Increment Iterator */
	cmp	w19,max		/* Check Iterator < max */
	b.ne	loop		/* Repeat if cmp ==false */

	mov	x0,0
	mov	x8,93
	svc	0

.data
msg:	.ascii	"Loop:   \n"
len = . - msg	
offset1 = msg + 6
offset2 = msg + 7

```